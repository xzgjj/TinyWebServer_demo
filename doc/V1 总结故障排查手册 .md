调试经历非常有价值，因为它覆盖了高性能网络编程中最核心的几个坑。梳理的一份**标准排查手册**：



## 高性能 WebServer 故障排查手册 (V1 总结)



### 1. 核心错误点 (Issues Found)



在本次调试中，抓到了 3 个“教科书级”的错误：

- **事件丢失 (Event Missing)**：读完数据后没有更新 `EPOLLOUT` 监听。数据存在了缓冲区（Buffer）里，但没有通知内核去发送。
- **配置错误 (Wrong CTL Mode)**：更新事件时误用了 `EPOLL_CTL_ADD` 覆盖已有的 FD，应该使用 `EPOLL_CTL_MOD`。
- **FD 类型混淆 (Variable Misuse)**：在 `epoll_ctl` 中错误地将“端口号 (8080)”当作“文件描述符 (FD)”传入。


---


### 2. 排查思路与过程 (Diagnostic Flow)



当我们面对一个“卡住且超时 (TIMEOUT)”的程序时，排查是自底向上进行的：



- **第一阶段：链路连通性检查**

**表象**：客户端显示 `TIMEOUT`。

**思考**：是服务器没收到（读）？还是收到了没发回（写）？

**手段**：在服务器 `HandleRead` 处打断点或加日志。

**结果**：发现服务器成功接收了 6 字节数据。**结论：读逻辑正常，问题出在回显（Write）环节。**

---

- **第二阶段：事件触发机制检查**

**思考**：为什么 `write` 没执行？在 Reactor 模式中，`write` 依赖 `EPOLLOUT` 事件。

**手段**：检查 `epoll_wait` 之后的逻辑，查看是否给该连接注册了“可写”兴趣。

**发现**：代码中虽然数据进了 Buffer，但并没有调用 `epoll_ctl` 去修改内核监听状态。



- **第三阶段：系统调用合法性检查**

**思考**：代码改了但依然报错？

**手段**：利用 `strace` 工具。这是 Linux 下最强的排查武器，它能看到程序对内核说的每一句话。

**发现**：`strace` 报错 `EBADF (Bad file descriptor)`，并显示操作的 FD 是 `8080`。**结论：参数传错了，内核拒绝执行。**


---


### 3. 调试过程详解 (GDB & Trace Steps)



这操过的关键步骤，建议收藏作为后续模板：

- **第一步：定位数据停留点 (GDB)**

代码段

```
(gdb) p conn.write_buffer_.size()
$1 = 6
```

- **意义**：确认了数据确实在服务器手里，排除了网络丢包的可能性。



- **第二步：追踪代码流向 (GDB list)**

代码段

```
(gdb) list 120, 130
```

**意义**：通过查看上下文，确认 `HandleRead()` 执行后是否有后续动作。我们当时发现 `UpdateInterest` 缺失或逻辑错误。



- **第三步：捕获系统级报错 (strace)**

```
strace ./server 2>&1 | grep epoll_ctl
```

**意义**：在不改代码的情况下，直接看内核反馈。

**结果**：看到了 `EEXIST` (重复添加) 或 `EBADF` (无效 FD)，直接指出了逻辑漏洞。


---


- **经验锦囊**



1. **Reactor 的灵魂是事件切换**：读（`IN`）和写（`OUT`）不是静态的。读完有数据要发，必须手动切到 `OUT`；发完缓冲区空了，必须切回 `IN`。否则会出现**忙轮询 (Busy Loop)** 或 **死等**。
2. **分清 FD 和 Port**：在内核眼里，FD 只是一个很小的索引（通常 < 1024），端口号只是地址的一部分。
3. **不要怕 make 报错**：重定义错误（Redefinition）通常是因为头文件和源文件重复写了逻辑。







