# 高性能网络库的**核心排错清单**





## 总体排错思路与方法论



在处理这类并发问题时，盲目打 Log 是低效的。我建议遵循以下方法：

1. **分层审计法**：由下至上检查（OS 事件通知 -> Poller 封装 -> Channel/Timer 分发 -> 业务回调）。
2. **资源归属权分析**：明确每个对象（TcpConnection, Timer, Buffer）生命周期由哪个线程持有。
3. **状态机模型化**：将连接的销毁、半关闭等逻辑抽象为有限状态机，检查非法跳转。
4. **离线与在线分析结合**：利用 `Valgrind` 和 `AddressSanitizer (ASan)` 定位内存错误，使用 `strace` 追踪系统调用轨迹。



---



## 核心问题



### `EMFILE` 处理与死循环 (The EMFILE Loop)



- **深度解析**：在 Level Trigger (LT) 模式下，`epoll_wait` 会不断通知你有新连接。但如果进程的文件描述符达到上限，`accept` 会失败并返回 `EMFILE`。因为你没能成功 `accept` 并取出这个连接，它会一直留在内核的监听队列里。下一次 `epoll_wait` 依然会立即返回，导致 CPU 100% 并在日志中疯狂报错。
- **专家对策**：准备一个“救命 fd”。初始化时 `open("/dev/null")` 占住一个坑。遇到 `EMFILE` 时，`close` 掉这个坑，腾出位置给 `accept`，拿到新 fd 后立即 `close` 它（礼貌拒绝），然后再把 `/dev/null` 开回来。

---

### EventLoop 的异步唤醒机制 (Wakeup Fatigue)



- **深度解析**：Reactor 线程通常阻塞在 `epoll_wait`。如果你在其他线程想让这个 Loop 执行某个任务（如关闭连接），直接改状态是不行的，必须将其唤醒。
- **深度坑点**：如果使用 `eventfd` 唤醒，但忘记在 `handleRead` 中读走那 8 字节计数器，LT 模式会持续触发可读事件。此外，如果 `queueInLoop` 频率极高，频繁写 `eventfd` 会产生不必要的系统调用开销。
- **专家对策**：实现 `doPendingFunctors` 逻辑，在执行回调前先用一个局部 `vector` 交换（`swap`）掉待执行队列，减小锁的粒度。



---

### 对象生命周期的“僵尸”状态 (Object Lifetime)



- **深度解析**：最难排查的 `Segmentation Fault`。当 `TcpConnection` 被业务层析构时，可能 `Channel` 还在处理内核传回的事件。
- **关键场景**：你在 `onMessage` 回调里执行了 `delete conn`，但回调结束后，Reactor 框架可能还会访问 `conn` 的成员变量。
- **专家对策**：**强弱指针结合**。`TcpConnection` 必须由 `std::shared_ptr` 管理。在 `Channel` 触发事件时，内部先 `tie` 住（`weak_ptr::lock`）对应的 `TcpConnection`。只要回调没跑完，引用计数就不为 0，对象就不会死。



---

### Epoll 事件数组中的“幽灵指针” (Dangling PTR in Events)



- **深度解析**：假设一次 `epoll_wait` 返回了 5 个就绪事件。在处理第 1 个事件时，逻辑上关掉了第 4 个事件对应的 `Channel` 并销毁了它。当循环走到第 4 个事件时，`events[i].data.ptr` 指向的内存已经是野指针了。
- **专家对策**：在 `Channel` 销毁前，务必调用 `epoll_ctl(EPOLL_CTL_DEL)`。但这还不够，最稳妥的方法是在 `EventLoop` 中标记“正在处理事件”，如果是当前正在处理的事件列表中的对象，延迟到下一轮 Loop 销毁。

---



###  写缓冲区的“大坝溢出” (Write Buffer OOM)



- **深度解析**：非阻塞 IO 下，`write` 并不保证发完所有数据。剩下的数据会存在应用层发送缓冲区。如果对端接收极慢，发送端却一直在 `send`，缓冲区会无限膨胀。
- **专家对策**：监控 `outputBuffer_.readableBytes()`。设定一个“高水位线”（High Water Mark），超过则停止读取应用数据并触发回调；同时关注 `WriteCompleteCallback`，当缓冲区清空后再恢复生产。

---



### ET 模式的“一次性”陷阱 (ET Starvation)



- **深度解析**：Edge Trigger (ET) 仅在状态变化（由不可读变可读）时通知一次。
- **常见错位**：如果一次 `read` 没读完缓冲区数据就去执行别逻辑了，内核不会再提醒你，除非对端再次发送新数据。这会导致请求“卡住”。
- **专家对策**：必须使用 `while(true)` 读到 `EAGAIN`。对 `accept` 同样适用，因为一次握手包可能同时带来多个就绪连接。

---



###  定时器管理的 O(N) 隐患 (Timer Efficiency)



- **深度解析**：初学者喜欢用 `gettimeofday` 遍历所有连接。当连接数过万，这种 $O(N)$ 的扫描会拖垮 Reactor。
- **专家对策**：使用 Linux 特有的 `timerfd_create`，它能把定时器超时转化为一个 IO 事件。配合 `std::set` 存储定时器（按超时时间排序），每次只取 `begin()` 那个最近的超时时间。

---



### SO_REUSEPORT 与惊群 (Thundering Herd)



- **深度解析**：多线程同时 `accept` 一个 socket 会导致 CPU 瞬间飙升。
- **专家对策**：在内核 3.9+ 以后，开启 `SO_REUSEPORT`，让内核在多个监听相同端口的进程/线程间实现负载均衡。这比在用户态加锁抢 `accept` 效率高得多。

---



### SIGPIPE 信号导致的进程崩溃



- **深度解析**：如果对端已关闭连接，你第一次写会收到 `RST`，第二次写内核会发 `SIGPIPE` 信号。该信号默认行为是终止进程。
- **专家对策**：在 Reactor 初始化时，必须显式调用 `signal(SIGPIPE, SIG_IGN)` 或使用 `send` 的 `MSG_NOSIGNAL` 标志。

---



### Eventfd 的伪唤醒与状态一致性

- **深度解析**：在高并发下，唤醒信号可能被累积。
- **专家对策**：即使 `epoll` 告诉你有事件，也要检查自己的任务队列是否为空。同时，一定要确保 `write` 唤醒和 `read` 清空操作是配对的。

---





### 缓冲区指针漂移 (Buffer Fragmentation)



- **深度解析**：频繁的 `read`/`write` 会导致 Buffer 的 `readIndex` 向后偏移，前面留下大量空洞。
- **专家对策**：实现“自动紧凑化”逻辑。当剩余空间不足以容纳新数据，但前面有空洞时，调用 `std::copy` 将数据移回起始位置。

---





### 锁与回调的死锁 (Callback Deadlock)



- **深度解析**：`Library -> Callback -> Library` 这种重入调用很容易死锁。例如：在 `onMessage` 回调（持有锁 A）中，又调用了修改底层属性的方法（尝试获取锁 A）。
- **专家对策**：**绝对不要在持有锁的情况下调用用户提供的回调函数**。先取数据、拷贝、解锁，再回调。

---

