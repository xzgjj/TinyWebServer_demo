
# 线程池

会创建一个全局或成员变量 ThreadPool pool(4)

join() 的作用：如果不调用 join()，主程序退出时，子线程可能还没跑完就被系统强制杀掉，会导致程序崩溃（Segmentation Fault）。
std::move 的作用：任务（Task）可能是一个复杂的 Lambda。使用 std::move 而不是拷贝，可以提高性能，避免不必要的内存分配。
双重检查 stop_：在 Worker 循环中，必须检查 stop_ && tasks_.empty()。这保证了即使线程池要关闭，也会先把队列里剩下的活干完。

修改 main.cpp 和 epoll_reactor.cp
V1 的单线程模式正式改为“线程池”模式

V3 真正的 WebServer
目前你的服务器虽然快，但它只是一个 Echo Server（原样返回数据）。要成为真正的 WebServer，我们需要引入 HTTP 协议解析。


## V2 架构的关键点


Lambda 捕获：reactor.SetOnMessage 捕获了 pool 的指针，这样在 onMessage 触发时，能访问到线程池。
非阻塞分发：pool->AddTask(...) 是立即返回的。这意味着主线程（Reactor）在毫秒级内就完成了分发，立刻回到 epoll_wait 准备处理下一个新连接。
并发处理：如果有 4 个客户端同时发请求，线程池里的 4 个 Worker 线程可以并行构造 HTTP 响应报文，不再需要排队。

文件,核心修改点
CMakeLists.txt,引入 find_package(Threads)，链接 pthread 库。
thread_pool.h/cpp,[新增] 实现任务队列、互斥锁和条件变量同步逻辑。
connection.h/cpp,继承 shared_from_this；HandleRead 改为接收回调函数并将数据传回。
epoll_reactor.cpp,容器改为 unordered_map；事件触发时通过 shared_ptr 派发异步任务。
main.cpp,初始化 ThreadPool；定义 SetOnMessage 里的异步 Lambda 逻辑。


### std::shared_ptr

V1 迈向 V3 的必经之路：引入 std::shared_ptr 管理连接生命周期。

/connection.h


### 测试

程池负责逻辑。由于线程调度存在毫秒级的延迟，客户端如果“发送后立即读取”，大概率会读到空字符串，从而触发 Assertion failed。