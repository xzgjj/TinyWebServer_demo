# v6

Reactor = 一个“事件 → 状态 → 行为”的驱动框架

大量连接怎么管？	统一事件源（epoll）
IO 什么时候能做？	内核通知
每个连接当前在干嘛？	状态机
怎么避免阻塞？	非阻塞 + 事件驱动

资深工程师眼里：

epoll：只是“事件通知机制”
Connection：状态机实体
你应该在脑子里画出这样一个状态图（非常重要）

[NEW]
  |
  v
[CONNECTED]
  |
  | EPOLLIN
  v
[READING]
  |
  | request complete
  v
[PROCESSING]
  |
  v
[WRITING]
  |
  | keep-alive?
  +-----> [READING]
  |
  v
[CLOSED]

epoll 给你的只有三件事：
EPOLLIN：现在可以读
EPOLLOUT：现在可以写
EPOLLERR / HUP：出问题了

epoll 不会告诉你：
读多少？请求是不是完整？现在该不该写？写到哪一步了？
这些全部靠 Connection 自己的状态机判断

模式	在项目中的真实体现
Reactor	epoll + event loop
State	Connection 的读 / 写阶段
RAII	fd / buffer 生命周期
Dispatcher	epoll → Connection

Reactor 和 Proactor 的核心区别？
Reactor：内核通知“可以做 IO 了”

用户态自己做 read/write
Proactor：内核直接完成 IO用户只处理结果（完成事件）


为什么 epoll 一定要配合状态机？
正确回答：因为 IO 是不完整、不可预期的
Reactor 必须把“未完成的上下文”保存在连接对象中
状态机是唯一可靠方式

标准工程回答：
LT：实现简单，不易漏事件
ET：性能更高，但要求一次读空 / 写满
demo / 教学项目优先 LT
工程化后再 ET + 严格循环读写

---

## 目标

v5 的真实定位（你现在的位置）

单 Reactor   单线程 event loop
同步日志   用户态 buffer IO
无超时 / back-pressure
无真正性能边界控制



v6 是一个：支持高并发、可观测、可演进、
明确区分 IO 与业务的工程级 Reactor 框架

Main Reactor
只负责：listen  accept  分发 fd

Sub Reactor（N 个）
各自：epoll Connection 生命周期  IO 状态机


                ┌───────────────┐
                │   Acceptor    │
                │  (MainLoop)   │
                └──────┬────────┘
                       │
         ┌─────────────┴─────────────┐
         │                           │
 ┌───────────────┐           ┌───────────────┐
 │ SubReactor #1 │           │ SubReactor #N │
 │ (IO Thread)   │   ...     │ (IO Thread)   │
 └──────┬────────┘           └──────┬────────┘
        │                               │
   Connection FSM                 Connection FSM
        │                               │
        └───────┬───────────────┬───────┘
                │               │
         Async Logger       Timer / Timeout
                │
           Log Thread


v6 Logger 架构
IO Thread
  |
  |  push(LogEvent)
  v
Lock-free / MPMC Queue
  |
  v
Logger Thread
  |
  v
Batch write + flush
