
# v4

静态资源系统 (V4 目标)
“双缓冲”架构异步日志

我希望v4实现 V4 (Infrastructure): 引入异步日志和定时器（踢掉僵尸连接）。
v5 引入静态资源系统和 mmap 传输



异步日志 (Async Logging)：不能直接在业务线程里写磁盘（太慢）。实现一个双缓冲（Double Buffering）日志系统，由专门的后端线程负责落盘。

状态看板：通过 HTTP 接口（如访问 /status）返回当前连接数、线程池负载、吞吐量 (QPS) 等指标。

1. 架构纵深：从 WebServer 到“高性能框架”
你可以尝试脱离简单的网页显示，把项目打造成一个底层框架：
支持 HTTPS：集成 OpenSSL，学习 SSL/TLS 握手过程。这是目前大厂面试非常看重的点。
CGI 与动态接口：模仿 Python 的 Flask 或 Java 的 Servlet，让用户可以注册自己的 URL 处理函数。
分布式接入：尝试把这个 WebServer 改造成一个 RPC 框架 的底层通信模块（例如基于 Protobuf 协议）。

 针对你面试/简历的建议实现路径
如果你是为了秋招/找工作，我建议接下来的优先级是：

定时器（展示你对数据结构和连接管理的理解）。
异步日志（展示你对多线程性能优化的极致追求）。
零拷贝/sendfile（展示你对 Linux 内核特性的掌握）。

main.cpp：调用 Server::Start() 进入无限循环，防止进程直接退出。
server.cpp：将 Start() 请求转发给 EpollReactor。
epoll_reactor.cpp：实现 Run() 函数，执行 epoll_wait 轮询。


extern bool g_running; // 声明 main.cpp 中的全局控制变量


// rc/epoll_reactor.cpp
void EpollReactor::Run() 

## 调式

调用阻塞， 逻辑


分包问题：HTTP 请求可能分多次到达。如果第一次 HandleRead 只读到了 GET /mu，你调用了回调并清空了 Buffer。
解析失败：on_message_ 里的 parser->Parse(buffer) 发现数据不完整，返回 false，不发送任何数据。
数据丢失：下一次 HandleRead 读到剩下的 lti HTTP/1.1... 时，之前的 GET /mu 已经被你 Clear 掉了。解析器永远无法拼凑出一个完整的 HTTP 报文。
死锁超时：解析器永远不成功 -> 永远不执行 conn->Send() -> 测试程序永远在等待 -> 60秒后测试程序超时并断开连接（Connection reset）。

缓冲区读取与任务竞争
目前最可能的瓶颈在于 Connection::Recv 与线程池任务的执行顺序 存在冲突，导致数据在被解析前就被破坏或丢失。

ET (Edge Triggered) 模式，如果 main.cpp 中的线程池任务执行得太慢，或者 HttpParser 还没有处理完数据，下一次 HandleRead 触发时，新的 Recv() 可能会覆盖掉旧的数据，或者因为你之前为了修复问题移除了 ClearReadBuffer，导致 read_buffer_ 里的数据不断堆积，而 HttpParser 每次都从头开始解析，陷入死循环或解析失败。


AddressSanitizer (ASan) 报错消失了。这说明我们对 TimerManager 的重构成功解决了堆溢出崩溃问题

